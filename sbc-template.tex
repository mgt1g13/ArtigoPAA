\documentclass[12pt]{article}

\usepackage{sbc-template}
%\usepackage{pr ogram}
\usepackage{algpseudocode}
\usepackage{algorithm}
%\usepackage{Algorithm2e}
\usepackage{graphicx,url}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

%\renewcommand{\algorithmiccomment}[1]{\bgroup\hfill//~#1\egroup}
     
\sloppy

\title{Problema do Máximo Subarray\\ Uma Análise de sua Complexidade}

\author{Matheus Garay Trindadel\inst{1}, Guilherme de Freitas Gaiardo\inst{1} }


\address{Departamento de Eletrônica e Computação -- Universidade Federal de Santa Maria\\
  (UFSM)\\
  97.105-900 -- Santa Maria -- RS -- Brazil\\
  \email{\{mtrindade,ggaiardo\}@inf.ufsm.br}
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução}

Em computação é recorrente encontrar problemas que, devido a limitações dos computares, não se é possível resolver em tempo hábil para certas entradas. Muitas vezes, algoritmos completamente funcionais para entradas pequenas se tornam inutilizáveis para entradas grandes. No intuito de prever o desempenho de algoritmos, podemos usar técnicas para estimar o crescimento da quantidade de instruções necessárias para resolver um dado problema em função do tamanho da entrada. Vale ressaltar que essas técnicas são independentes de arquitetura e simplesmente mostram como o custo computacional se comporta.

Para exemplificar esse conceito, esse artigo faz uma análise computacional do problema clássico do máximo subarray. Nessa análise, serão apresentadas apresentados três algoritmos que resolvem esse problema. Cada um desses algoritmos possui uma complexidade, i.e., um crescimento do custo computacional, diferente. Essas complexidades serão demonstradas usando diversas técnicas, dependendo da estrutura do algoritmo.

\section{Problema do Subarray Máximo} \label{sec:firstpage}

O clássico problema do subarray máximo consiste do seguinte: dado um array de valores contendo valores negativos, encontrar o subarray que, dentro do conjunto de subarrays do array original, se somarmos os valores de seus elementos, possui a maior soma. Por exemplo, podemos tomar o array A apresentado na sequência:

\begin{center}
$A = [13, -3, -25, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]$
\end{center}

Observando o array, percbemos que o subarray com a soma máxima consite em:

\begin{center}
$ [18, 20, -7, 12]$
\end{center}

A soma desse subarray corresponde a 43. Nenhum outro subarray possui uma soma superior a esta. O problema então consiste em escrever um algoritmo para analisar o conjunto de subarrays e achar o que maximiza a soma de seus elementos.





%Discutir sobre O, THETA e Omega?

\section{Soluções para o Problema}

A seguir, serão discutidas diversas formas de resolver o problema. Além disso, uma extensiva análise da solução será feita para demonstrar a complexidade em cada caso.
\subsection{Força Bruta}

A solução talvez mais óbvia e simples consiste em, exaustivamente, calcular todos os subarrays e compará-los entre si. O algoritmo consiste em dois laços aninhados para montar todos os subarrays. A soma é computada e salva. Se a soma for maior que a maior soma corrente (ou não existir soma corrente), ela passa ser a maior soma e o subarray máximo passa a ser o subarray que gerou esta soma. A solução é melhor apresentada no seguinte pseudocódigo:
\\

%\sum\limits_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}
%\begin{center}
\begin{algorithm}[H]
  \caption{Força Bruta}\label{bruteforce}
  \begin{algorithmic}[1]
    \Function{maxSubarray}{$A$}%\Comment{The g.c.d. of a and b}
     \State \texttt{$maxSoma \gets -\infty$} \Comment{\parbox[t]{.2\linewidth}{$1$}}
     \State \texttt{$n \gets len(A)$} \Comment{\parbox[t]{.2\linewidth}{$1$}}
     \State \texttt{$i0 \gets -1$} \Comment{\parbox[t]{.2\linewidth}{$1$}}
     \State \texttt{$j0 \gets -1$} \Comment{\parbox[t]{.2\linewidth}{$1$}}
      \For{$i \in [1:n]$} \Comment{\parbox[t]{.2\linewidth}{$n+1$}}
      \State \texttt{$soma \gets 0$} \Comment{\parbox[t]{.2\linewidth}{$n$}}
    \For{$j \in [i:n]$}\Comment{\parbox[t]{.2\linewidth}{$\sum\limits_{i=1}^{n+1} i = \frac{n^2 +3n + 2}{2}$}}
      \State \texttt{$soma \gets soma + A[j]$} \Comment{\parbox[t]{.2\linewidth}{$\sum\limits_{i=1}^{n} i = \frac{n^2 +n}{2}$}}
      \If{$soma > maxSoma$} \Comment{\parbox[t]{.2\linewidth}{$\sum\limits_{i=1}^{n} i = \frac{n^2 +n}{2}$}}
        \State \texttt{$maxSoma \gets soma$} \Comment{\parbox[t]{.2\linewidth}{$\sum\limits_{i=1}^{n} t_j$}}
        \State \texttt{$i0 \gets i$}\Comment{\parbox[t]{.2\linewidth}{$\sum\limits_{i=1}^{n} t_j$}}
        \State \texttt{$j0 \gets j$}    \Comment{\parbox[t]{.2\linewidth}{$\sum\limits_{i=1}^{n} t_j$}}   
      \EndIf

        \EndFor          
      \EndFor
      \State \textbf{return} $A[i0:j0]$ \Comment{\parbox[t]{.2\linewidth}{$1$}}
    \EndFunction
  \end{algorithmic}
\end{algorithm}


\subsection{Divisão e Conquista}

Uma solução mais eficiente e elaborada é utilizar a tecnica de divisão e conquista. A solução é definida recursivamente, dividindo o array original em arrays menores, até chegar ao caso básico onde existe somente um elemento. A ideia geral do algoritmo é dividir em três possibilidades. Ou o subarray máximo está à esquerda do meio do array, ou está à direita ou então está passando pelo meio do array. O algoritmo irá realizar a chamada recursiva para os dois primeiros casos, e para o caso de estar no meio, é utilizado uma chamada especial onde é calculado o subarray máximo de forma linear. Ao fim das chamadas recursivas, é verificado qual foi o retorno com a maior soma (maior subarray).
A seguir, apresentamos o algoritmo em pseudocódigo.

\begin{algorithm}[H]
  \caption{Divisão e Conquista}\label{divideAndConquer}
  \begin{algorithmic}[1]
  
  \Function{FindMaxCrossingSubarray}{$A, low, mid, high$}  
\State \texttt{$  left\_sum = -\infty$}
\State \texttt{$  soma = 0$}
\State \texttt{$  max\_left = mid$}
  \For{$ i = mid~;~i > low-1~;~ i = i -1 $}
    \State \texttt{$    soma =  soma + a[i]$}
    \If{$soma >left_sum$}
    \State \texttt{$      left\_sum = soma$}
    \State \texttt{$      max\_left = i$}
    \EndIf
  \EndFor
\State

\State \texttt{$	right\_sum =-\infty$}
\State \texttt{$	soma = 0$}
\State \texttt{$	max\_right = mid$}
	\For{$ i = mid+1 ; i< high+1 ; i = i + 1):$}
		\State \texttt{$		soma = som + a[i]$}
		\If{$soma >right_sum$}
			\State \texttt{$			right\_sum = soma$}
			\State \texttt{$			max\_right = i$}
		\EndIf

\EndFor
\State \texttt{$  return (max\_left, max\_right, right\_sum + left\_sum)$}
  
  \EndFunction \State \State
  
  
    \Function{SubarrayMaximoDivEConq}{$A, low, high$}%\Comment{The g.c.d. of a and b}
    
    \If{$low = high$}
    \State \textbf{return} $(low, high, A[low])$
    \EndIf
  \State    
    \State \texttt{$mid \gets \lfloor \frac{low + high}{2} \rfloor$}
  \State
\State \texttt{$  (l\_low, l\_high, l\_sum) = SubarrayMaximoDivEConq(a, low, mid)$}
\State \texttt{$  (r\_low, r\_high, r\_sum) = SubarrayMaximoDivEConq(a, mid+1, high)$}
\State \texttt{$  (c\_low, c\_high, c\_sum) = findMaxCrossingSubarray(a, low, mid, high)$}
  \State
  \If{$l\_sum >= r\_sum and l\_sum >= c\_sum$}
        \State \textbf{return} $(l\_low, l\_high, l\_sum)$
  
  \ElsIf {$r\_sum >= l\_sum and r\_sum >= c\_sum$}
        \State \textbf{return} $(r\_low, r\_high, r\_sum])$
  \Else
        \State \textbf{return} $(c\_low, c\_high, c\_sum])$
  \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Teorema Mestre}

O teorema mestre é uma solução assintótica, utilizando a notação O Grande, para análise do comportamento de algoritmos que empregam tecnicas de divisão e conquista. Ele não resolve qualquer recorrencia, no entanto.

O teorema mestre resolve recorrencias da forma:
\begin{center}
$T(n) = aT(n/b) + f(n)$
\end{center}
onde $a>=1$ e $b>1$. Sendo $n$ o tamanho da entrada, $a$ o número de divisões por recursão, $n/b$ é o tamanho do subproblema da proxima recursão e $f(n)$ é o custo envolvido em computações fora das chamadas recursivas e o custo de junção das soluções.
Existem três casos onde é possível determinar o crescimento do custo:

Se $f(n) \in O(n^c)$ onde $c< log_b a$, então a solução é $T(n) \in \theta(n^{log_b a})$.

O segundo caso é válido se, dado uma constante $k >= 0$ que satisfaça a seguinte relação: $f(n) = \theta(n^c log^k n)$ onde $c = log_b a$
então a solução é $T(n) = \theta(n^c log^{k+1} n)$.

O terceiro e último caso é válido se $f(n) = \omega(n^c)$ onde $c > log_b a$ e $af(n/b) <= kf(n)$ para uma constante $k<1$ e um $n$ suficientemente grande. Então a solução é $T(n) = \theta(f(n))$

Resolvendo com a estratégia de divisão e conquista o problema do sub array máximo, podemos verificar que:
\begin{center}
$T(n) = 2T(n/2) + n$
\end{center}
onde $a=2$ (as duas chamadas por nível de recursão), $b=2$ (o problema é dividido ao meio), e $f(n) = n$ (tempo linear da chamada da função que verifica o meio do array).

Sendo $c=log_b a=log_2 2=1$ e $f(n) = \theta(n^c log^k n)$ onde $k=0$, as condições estão satisfeitas, aplicando o teorema temos:
\begin{center}
$T(n) = \theta(nlog n)$
\end{center}


\section{Figures and Captions}\label{sec:figs}


Figure and table captions should be centered if less than one line
(Figure~\ref{fig:exampleFig1}), otherwise justified and indented by 0.8cm on
both margins, as shown in Figure~\ref{fig:exampleFig2}. The caption font must
be Helvetica, 10 point, boldface, with 6 points of space before and after each
caption.

\begin{figure}[ht]
\centering
\includegraphics[width=.5\textwidth]{fig1.jpg}
\caption{A typical figure}
\label{fig:exampleFig1}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=.3\textwidth]{fig2.jpg}
\caption{This figure is an example of a figure caption taking more than one
  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
\label{fig:exampleFig2}
\end{figure}

In tables, try to avoid the use of colored or shaded backgrounds, and avoid
thick, doubled, or unnecessary framing lines. When reporting empirical data,
do not use more decimal digits than warranted by their precision and
reproducibility. Table caption must be placed before the table (see Table 1)
and the font used must also be Helvetica, 10 point, boldface, with 6 points of
space before and after each caption.

\begin{table}[ht]
\centering
\caption{Variables to be considered on the evaluation of interaction
  techniques}
\label{tab:exTable1}
\includegraphics[width=.7\textwidth]{table.jpg}
\end{table}

\section{Images}

All images and illustrations should be in black-and-white, or gray tones,
excepting for the papers that will be electronically available (on CD-ROMs,
internet, etc.). The image resolution on paper should be about 600 dpi for
black-and-white images, and 150-300 dpi for grayscale images.  Do not include
images with excessive resolution, as they may take hours to print, without any
visible difference in the result. 

\section{References}

Bibliographic references must be unambiguous and uniform.  We recommend giving
the author names references in brackets, e.g. \cite{knuth:84},
\cite{boulic:91}, and \cite{smith:99}.

The references must be listed using 12 point font size, with 6 points of space
before each reference. The first line of each reference should not be
indented, while the subsequent should be indented by 0.5 cm.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
